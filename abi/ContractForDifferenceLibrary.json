{
  "contractName": "ContractForDifferenceLibrary",
  "abi": [],
  "metadata": "{\"compiler\":{\"version\":\"0.5.6+commit.b259423e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{},\"title\":\"Contract for difference * Contract for difference for a given market between a \\\"buyer\\\" (long position) and \\\"seller\\\" (short position).\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/home/julien/0xFutures/protocol/contracts/cfd/ContractForDifferenceLibrary.sol\":\"ContractForDifferenceLibrary\"},\"evmVersion\":\"constantinople\",\"libraries\":{},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"/home/julien/0xFutures/protocol/contracts/cfd/ContractForDifferenceLibrary.sol\":{\"keccak256\":\"0x7d8b4fae4675864c273b85f2b8a7ed8bc8f504b49f2955b0f69b694c30ec2771\",\"urls\":[\"bzzr://47e963e227389af89263baa271e1ec5c54c192883ec2697801807c3827110952\"]},\"openzeppelin-solidity/contracts/math/SafeMath.sol\":{\"keccak256\":\"0x965012d27b4262d7a41f5028cbb30c51ebd9ecd4be8fb30380aaa7a3c64fbc8b\",\"urls\":[\"bzzr://41ca38f6b0fa4b77b0feec43e422cfbec48b7eb38a41edf0b85c77e8d9a296b1\"]}},\"version\":1}",
  "bytecode": "0x604c6023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a723058203e4918935b1bb42f051699fd85f61ab481f98e725455af1560ddb46a5a1e17780029",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a723058203e4918935b1bb42f051699fd85f61ab481f98e725455af1560ddb46a5a1e17780029",
  "sourceMap": "245:6825:6:-;;132:2:-1;166:7;155:9;146:7;137:37;255:7;249:14;246:1;241:23;235:4;232:33;222:2;;269:9;222:2;293:9;290:1;283:20;323:4;314:7;306:22;347:7;338;331:24",
  "deployedSourceMap": "245:6825:6:-;;;;;;;;",
  "source": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Contract for difference\n *\n * Contract for difference for a given market between a\n * \"buyer\" (long position) and \"seller\" (short position).\n */\nlibrary ContractForDifferenceLibrary {\n    using SafeMath for uint;\n\n    uint internal constant FACTOR_UINT = 10 ** 20; // raise numbers to avoid fractions\n    int  internal constant FACTOR_INT = int(FACTOR_UINT);\n\n    uint internal constant MINIMUM_COLLATERAL_PERCENT = 20; // 5x leverage\n    uint internal constant MAXIMUM_COLLATERAL_PERCENT = 500; // 0.2x leverage\n\n    // 5% of collateral triggers a liquidate\n    uint internal constant LIQUIDATE_THRESHOLD_PERCENT = 5;\n\n    // 5% as 0.05 adjusted up by the FACTOR (to avoid a fraction)\n    uint internal constant LIQUIDATE_THRESHOLD_PERCENT_RAISED = LIQUIDATE_THRESHOLD_PERCENT * FACTOR_UINT / 100;\n\n    // Buyer and seller initial adjustment in cut off formulas.\n    // Declare constants up here to save gas.\n    uint constant BUYER_CUTOFF_ADJUSTMENT = (FACTOR_UINT * 105) / 100; // 1.05\n    uint constant SELLER_CUTOFF_ADJUSTMENT = (FACTOR_UINT * 95) / 100; // 0.95\n\n\n    /**\n     * @dev Calculate new notional amount after a side has been sold at a new\n     *      strike price.\n     *\n     * Formula is:\n     *  N2 = N1 * S2 / S1\n     * Where:\n     *  N1 = previous notional\n     *  S1 = previous strike price\n     *  S2 = sale strike price\n     *\n     * @param _oldNotional Existing notional.\n     * @param _oldStrikePrice Existing strike price.\n     * @param _newStrikePrice New / Sale strike price.\n     * @return newNotional Result of the calculation.\n     */\n    function calculateNewNotional(\n        uint _oldNotional,\n        uint _oldStrikePrice,\n        uint _newStrikePrice\n    )\n        internal\n        pure\n        returns (uint newNotional)\n    {\n        newNotional = (\n            _oldNotional.mul(\n                (_newStrikePrice.mul(FACTOR_UINT) / (_oldStrikePrice))\n            )\n        ) / (FACTOR_UINT);\n    }\n\n    /**\n     * @dev Calculate the change in contract value based on the price change.\n     * @param _currentPrice Current market price\n     */\n    function changeInDai(\n        uint _strikePrice,\n        uint _currentPrice,\n        uint _notionalAmount\n    )\n        internal\n        pure\n        returns (uint change)\n    {\n        uint changePercent = percentChange(_strikePrice, _currentPrice);\n        change = percentOf(_notionalAmount, changePercent);\n    }\n\n    /**\n     * @dev Return a percentage change comparing a value with a new value.\n     * @param _value The existing value to compare against\n     * @param _newValue The new value to compare the change against\n     * @return Percentage change (eg. _value = 100, _newValue = 90 then return 10)\n     */\n    function percentChange(uint _value, uint _newValue)\n        internal\n        pure\n        returns (uint percent)\n    {\n        if (_value == _newValue) return 0;\n        int changeAmount = int(_newValue) - int(_value);\n        int percentInt = (changeAmount * 100) / int(_value);\n        percent = uint((percentInt > 0) ? percentInt : -percentInt);\n    }\n\n    /**\n     * @dev Return a percentage of a given amount.\n     * @param _amount Amount to calculate the percentage of\n     * @param _percent Percent amount (1 - 100)\n     */\n    function percentOf(uint _amount, uint _percent)\n        internal\n        pure\n        returns (uint adjusted)\n    {\n        adjusted = (_amount * _percent) / 100;\n    }\n\n    /**\n     * @dev Calculate the collateral amount for one party given the current\n     *      market price and original strike price, notional amount and the\n     *      amount the party has deposited into the contract.\n     *\n     * @param _marketPrice Current market price\n     * @param _strikePrice CFD strike price\n     * @param _notionalAmount CFD notional amount\n     * @param _depositBalance Balances of deposits into the contract\n     * @param _isBuyer Buyer or Seller / Long or short party?\n     *\n     * @return collateral Amount of collateral for the party\n     */\n    function calculateCollateralAmount(\n        uint _strikePrice,\n        uint _marketPrice,\n        uint _notionalAmount,\n        uint _depositBalance,\n        bool _isBuyer\n    )\n        internal\n        pure\n        returns (uint collateral)\n    {\n        // Formulas are:\n        //     Cl = depositBalanceLong  + N * (P - S) / S\n        //     Cs = depositBalanceShort - N * (P - S) / S\n        // however we need to use a multiplication factor to avoid fractions in\n        // solidity so these formulas are a little different to the above:\n        int N = int(_notionalAmount) * FACTOR_INT;\n        int So = int(_strikePrice);\n        int P = int(_marketPrice);\n        int D = int(_depositBalance);\n\n        int difference = (\n            N * (((P - So) * FACTOR_INT) / So) / FACTOR_INT\n        ) / FACTOR_INT;\n        int collateralInt = _isBuyer ? D + difference : D - difference;\n\n        assert(collateralInt >= 0);\n        collateral = uint(collateralInt);\n    }\n\n    function collateralInRange(\n        uint _notionalAmount,\n        uint _amount\n    )\n        internal\n        pure\n        returns (bool inRange)\n    {\n        inRange = (_amount >= percentOf(_notionalAmount, MINIMUM_COLLATERAL_PERCENT)) &&\n            (_amount <= percentOf(_notionalAmount, MAXIMUM_COLLATERAL_PERCENT));\n    }\n\n    /**\n     * @dev Calculate the cut off price for buyer or seller.\n     *\n     * This is the price that if passed would raise a liquidation event.\n     *\n     * Base Formulas are:\n     *     Buyer:  1.05 * S - depositBalanceLong  * S / N\n     *     Seller: 0.95 * S + depositBalanceShort * S / N\n     *\n     * However for Solidity we need to adjust parts by FACTOR_UINT to ensure\n     * no fractions.\n     *\n     * @param _notionalAmountDai Contract notional amount\n     * @param _depositBalance Balance of deposits for one party\n     *\n     * @return cut off price\n     */\n\n    function cutOffPrice(\n        uint _notionalAmountDai,\n        uint _depositBalance,\n        uint _strikePrice,\n        bool _calcForBuyerSide\n    )\n        internal\n        pure\n        returns (uint price)\n    {\n        // 1st part: Buyer: [1.05 * S] or Seller: [0.95 * S]\n        uint strikePriceAdjuster = (_calcForBuyerSide) ?\n            BUYER_CUTOFF_ADJUSTMENT :\n            SELLER_CUTOFF_ADJUSTMENT;\n        uint strikeFivePercent = (_strikePrice * strikePriceAdjuster) / FACTOR_UINT;\n\n\n        // 2nd part: [depositBalance * S / N]\n        uint difference = (\n            _depositBalance * (_strikePrice * FACTOR_UINT) / _notionalAmountDai\n        ) / FACTOR_UINT;\n\n        // check for case where difference is greater (when buyer has deposits > notional)\n        // in this case we set the price to 0\n        if (_calcForBuyerSide && difference > strikeFivePercent)\n            return 0;\n\n        // finally: add or subtract the difference\n        price = (_calcForBuyerSide) ?\n            strikeFivePercent - difference :\n            strikeFivePercent + difference;\n    }\n\n}\n",
  "sourcePath": "/home/julien/0xFutures/protocol/contracts/cfd/ContractForDifferenceLibrary.sol",
  "compiler": {
    "name": "solc",
    "version": "0.5.6+commit.b259423e.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.8",
  "updatedAt": "2019-08-03T21:50:35.936Z",
  "devdoc": {
    "methods": {},
    "title": "Contract for difference * Contract for difference for a given market between a \"buyer\" (long position) and \"seller\" (short position)."
  },
  "userdoc": {
    "methods": {}
  }
}