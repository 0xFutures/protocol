{
  "contractName": "ContractForDifferenceLibrary",
  "abi": [],
  "bytecode": "0x604c602c600b82828239805160001a60731460008114601c57601e565bfe5b5030600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a7230582034aa05d4a1e66da310311797d0809cc84d98fbd40006ebe28c148436678cc2ed0029",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a7230582034aa05d4a1e66da310311797d0809cc84d98fbd40006ebe28c148436678cc2ed0029",
  "sourceMap": "245:7213:6:-;;132:2:-1;166:7;155:9;146:7;137:37;252:7;246:14;243:1;238:23;232:4;229:33;270:1;265:20;;;;222:63;;265:20;274:9;222:63;;298:9;295:1;288:20;328:4;319:7;311:22;352:7;343;336:24",
  "deployedSourceMap": "245:7213:6:-;;;;;;;;",
  "source": "pragma solidity ^0.5.0;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\n/**\n * @title Contract for difference\n *\n * Contract for difference for a given market between a\n * \"buyer\" (long position) and \"seller\" (short position).\n */\nlibrary ContractForDifferenceLibrary {\n    using SafeMath for uint;\n\n    uint internal constant FACTOR_UINT = 10 ** 20; // raise numbers to avoid fractions\n    int  internal constant FACTOR_INT = int(FACTOR_UINT);\n\n    uint internal constant MINIMUM_COLLATERAL_PERCENT = 20; // 5x leverage\n    uint internal constant MAXIMUM_COLLATERAL_PERCENT = 500; // 0.2x leverage\n\n    // 5% of collateral triggers a liquidate\n    uint internal constant LIQUIDATE_THRESHOLD_PERCENT = 5;\n\n    // 5% as 0.05 adjusted up by the FACTOR (to avoid a fraction)\n    uint internal constant LIQUIDATE_THRESHOLD_PERCENT_RAISED = LIQUIDATE_THRESHOLD_PERCENT * FACTOR_UINT / 100;\n\n    // Buyer and seller initial adjustment in cut off formulas.\n    // Declare constants up here to save gas.\n    uint constant BUYER_CUTOFF_ADJUSTMENT = (FACTOR_UINT * 105) / 100; // 1.05\n    uint constant SELLER_CUTOFF_ADJUSTMENT = (FACTOR_UINT * 95) / 100; // 0.95\n\n\n    /**\n     * Creator fee - 0.3% of notional.\n     */\n    function creatorFee(uint _notional) internal pure returns (uint fee) {\n        fee = percentOf(_notional, 3) / 10;\n    }\n\n    /**\n     * Joiner (deposit or buy) percentage fee - 0.5% of notional.\n     */\n    function joinerFee(uint _notional) internal pure returns (uint fee) {\n        fee = percentOf(_notional, 5) / 10;\n    }\n\n    /**\n     * @dev Calculate new notional amount after a side has been sold at a new\n     *      strike price.\n     *\n     * Formula is:\n     *  N2 = N1 * S2 / S1\n     * Where:\n     *  N1 = previous notional\n     *  S1 = previous strike price\n     *  S2 = sale strike price\n     *\n     * @param _oldNotional Existing notional.\n     * @param _oldStrikePrice Existing strike price.\n     * @param _newStrikePrice New / Sale strike price.\n     * @return newNotional Result of the calculation.\n     */\n    function calculateNewNotional(\n        uint _oldNotional,\n        uint _oldStrikePrice,\n        uint _newStrikePrice\n    )\n        internal\n        pure\n        returns (uint newNotional)\n    {\n        newNotional = (\n            _oldNotional.mul(\n                (_newStrikePrice.mul(FACTOR_UINT) / (_oldStrikePrice))\n            )\n        ) / (FACTOR_UINT);\n    }\n\n    /**\n     * @dev Calculate the change in contract value based on the price change.\n     * @param _currentPrice Current market price\n     */\n    function changeInDai(\n        uint _strikePrice,\n        uint _currentPrice,\n        uint _notionalAmount\n    )\n        internal\n        pure\n        returns (uint change)\n    {\n        uint changePercent = percentChange(_strikePrice, _currentPrice);\n        change = percentOf(_notionalAmount, changePercent);\n    }\n\n    /**\n     * @dev Return a percentage change comparing a value with a new value.\n     * @param _value The existing value to compare against\n     * @param _newValue The new value to compare the change against\n     * @return Percentage change (eg. _value = 100, _newValue = 90 then return 10)\n     */\n    function percentChange(uint _value, uint _newValue)\n        internal\n        pure\n        returns (uint percent)\n    {\n        if (_value == _newValue) return 0;\n        int changeAmount = int(_newValue) - int(_value);\n        int percentInt = (changeAmount * 100) / int(_value);\n        percent = uint((percentInt > 0) ? percentInt : -percentInt);\n    }\n\n    /**\n     * @dev Return a percentage of a given amount.\n     * @param _amount Amount to calculate the percentage of\n     * @param _percent Percent amount (1 - 100)\n     */\n    function percentOf(uint _amount, uint _percent)\n        internal\n        pure\n        returns (uint adjusted)\n    {\n        adjusted = (_amount * _percent) / 100;\n    }\n\n    /**\n     * @dev Calculate the collateral amount for one party given the current\n     *      market price and original strike price, notional amount and the\n     *      amount the party has deposited into the contract.\n     *\n     * @param _marketPrice Current market price\n     * @param _strikePrice CFD strike price\n     * @param _notionalAmount CFD notional amount\n     * @param _depositBalance Balances of deposits into the contract\n     * @param _isBuyer Buyer or Seller / Long or short party?\n     *\n     * @return collateral Amount of collateral for the party\n     */\n    function calculateCollateralAmount(\n        uint _strikePrice,\n        uint _marketPrice,\n        uint _notionalAmount,\n        uint _depositBalance,\n        bool _isBuyer\n    )\n        internal\n        pure\n        returns (uint collateral)\n    {\n        // Formulas are:\n        //     Cl = depositBalanceLong  + N * (P - S) / S\n        //     Cs = depositBalanceShort - N * (P - S) / S\n        // however we need to use a multiplication factor to avoid fractions in\n        // solidity so these formulas are a little different to the above:\n        int N = int(_notionalAmount) * FACTOR_INT;\n        int So = int(_strikePrice);\n        int P = int(_marketPrice);\n        int D = int(_depositBalance);\n\n        int difference = (\n            N * (((P - So) * FACTOR_INT) / So) / FACTOR_INT\n        ) / FACTOR_INT;\n        int collateralInt = _isBuyer ? D + difference : D - difference;\n\n        assert(collateralInt >= 0);\n        collateral = uint(collateralInt);\n    }\n\n    function collateralInRange(\n        uint _notionalAmount,\n        uint _amount\n    )\n        internal\n        pure\n        returns (bool inRange)\n    {\n        inRange = (_amount >= percentOf(_notionalAmount, MINIMUM_COLLATERAL_PERCENT)) &&\n            (_amount <= percentOf(_notionalAmount, MAXIMUM_COLLATERAL_PERCENT));\n    }\n\n    /**\n     * @dev Calculate the cut off price for buyer or seller.\n     *\n     * This is the price that if passed would raise a liquidation event.\n     *\n     * Base Formulas are:\n     *     Buyer:  1.05 * S - depositBalanceLong  * S / N\n     *     Seller: 0.95 * S + depositBalanceShort * S / N\n     *\n     * However for Solidity we need to adjust parts by FACTOR_UINT to ensure\n     * no fractions.\n     *\n     * @param _notionalAmountDai Contract notional amount\n     * @param _depositBalance Balance of deposits for one party\n     *\n     * @return cut off price\n     */\n\n    function cutOffPrice(\n        uint _notionalAmountDai,\n        uint _depositBalance,\n        uint _strikePrice,\n        bool _calcForBuyerSide\n    )\n        internal\n        pure\n        returns (uint price)\n    {\n        // 1st part: Buyer: [1.05 * S] or Seller: [0.95 * S]\n        uint strikePriceAdjuster = (_calcForBuyerSide) ?\n            BUYER_CUTOFF_ADJUSTMENT :\n            SELLER_CUTOFF_ADJUSTMENT;\n        uint strikeFivePercent = (_strikePrice * strikePriceAdjuster) / FACTOR_UINT;\n\n\n        // 2nd part: [depositBalance * S / N]\n        uint difference = (\n            _depositBalance * (_strikePrice * FACTOR_UINT) / _notionalAmountDai\n        ) / FACTOR_UINT;\n\n        // check for case where difference is greater (when buyer has deposits > notional)\n        // in this case we set the price to 0\n        if (_calcForBuyerSide && difference > strikeFivePercent)\n            return 0;\n\n        // finally: add or subtract the difference\n        price = (_calcForBuyerSide) ?\n            strikeFivePercent - difference :\n            strikeFivePercent + difference;\n    }\n\n}\n",
  "sourcePath": "/home/julien/0xFutures/protocol-master/contracts/cfd/ContractForDifferenceLibrary.sol",
  "compiler": {
    "name": "solc",
    "version": "0.5.0+commit.1d4f565a.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.2",
  "updatedAt": "2019-04-21T18:52:32.698Z",
  "devdoc": {
    "methods": {},
    "title": "Contract for difference * Contract for difference for a given market between a \"buyer\" (long position) and \"seller\" (short position)."
  },
  "userdoc": {
    "methods": {}
  }
}