{
  "contractName": "ContractForDifferenceLibrary",
  "abi": [],
  "metadata": "{\"compiler\":{\"version\":\"0.5.6+commit.b259423e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"methods\":{},\"title\":\"Contract for difference\\r  * Contract for difference for a given market between a\\r \\\"buyer\\\" (long position) and \\\"seller\\\" (short position).\\r\"},\"userdoc\":{\"methods\":{}}},\"settings\":{\"compilationTarget\":{\"/D/Users/Julien/Desktop/Work/0xFutures/protocol/contracts/cfd/ContractForDifferenceLibrary.sol\":\"ContractForDifferenceLibrary\"},\"evmVersion\":\"constantinople\",\"libraries\":{},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"/D/Users/Julien/Desktop/Work/0xFutures/protocol/contracts/cfd/ContractForDifferenceLibrary.sol\":{\"keccak256\":\"0xd21632a219bd5c99c5a02621f9f9053b122b8fa73a7da35bec9eb1db44b4dbcd\",\"urls\":[\"bzzr://a3a125dd74eed530fdbcf87a06902ab039c4e333d2231ce61616234d8d718a17\"]},\"openzeppelin-solidity/contracts/math/SafeMath.sol\":{\"keccak256\":\"0x965012d27b4262d7a41f5028cbb30c51ebd9ecd4be8fb30380aaa7a3c64fbc8b\",\"urls\":[\"bzzr://41ca38f6b0fa4b77b0feec43e422cfbec48b7eb38a41edf0b85c77e8d9a296b1\"]}},\"version\":1}",
  "bytecode": "0x604c6023600b82828239805160001a607314601657fe5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a723058200529c2b81e151556f028d5d8a17eaa5c358be880667098e26e35aeddab8913c70029",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600080fdfea165627a7a723058200529c2b81e151556f028d5d8a17eaa5c358be880667098e26e35aeddab8913c70029",
  "sourceMap": "255:7433:6:-;;132:2:-1;166:7;155:9;146:7;137:37;255:7;249:14;246:1;241:23;235:4;232:33;222:2;;269:9;222:2;293:9;290:1;283:20;323:4;314:7;306:22;347:7;338;331:24",
  "deployedSourceMap": "255:7433:6:-;;;;;;;;",
  "source": "pragma solidity ^0.5.0;\r\n\r\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\r\n\r\n/**\r\n * @title Contract for difference\r\n *\r\n * Contract for difference for a given market between a\r\n * \"buyer\" (long position) and \"seller\" (short position).\r\n */\r\nlibrary ContractForDifferenceLibrary {\r\n    using SafeMath for uint;\r\n\r\n    uint internal constant FACTOR_UINT = 10 ** 20; // raise numbers to avoid fractions\r\n    int  internal constant FACTOR_INT = int(FACTOR_UINT);\r\n\r\n    uint internal constant MINIMUM_COLLATERAL_PERCENT = 20; // 5x leverage\r\n    uint internal constant MAXIMUM_COLLATERAL_PERCENT = 500; // 0.2x leverage\r\n\r\n    // 5% of collateral triggers a liquidate\r\n    uint internal constant LIQUIDATE_THRESHOLD_PERCENT = 5;\r\n\r\n    // 5% as 0.05 adjusted up by the FACTOR (to avoid a fraction)\r\n    uint internal constant LIQUIDATE_THRESHOLD_PERCENT_RAISED = LIQUIDATE_THRESHOLD_PERCENT * FACTOR_UINT / 100;\r\n\r\n    // Buyer and seller initial adjustment in cut off formulas.\r\n    // Declare constants up here to save gas.\r\n    uint constant BUYER_CUTOFF_ADJUSTMENT = (FACTOR_UINT * 105) / 100; // 1.05\r\n    uint constant SELLER_CUTOFF_ADJUSTMENT = (FACTOR_UINT * 95) / 100; // 0.95\r\n\r\n\r\n    /**\r\n     * Creator fee - 0.3% of notional.\r\n     */\r\n    function creatorFee(uint _notional) internal pure returns (uint fee) {\r\n        fee = percentOf(_notional, 3) / 10;\r\n    }\r\n\r\n    /**\r\n     * Joiner (deposit or buy) percentage fee - 0.5% of notional.\r\n     */\r\n    function joinerFee(uint _notional) internal pure returns (uint fee) {\r\n        fee = percentOf(_notional, 5) / 10;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate new notional amount after a side has been sold at a new\r\n     *      strike price.\r\n     *\r\n     * Formula is:\r\n     *  N2 = N1 * S2 / S1\r\n     * Where:\r\n     *  N1 = previous notional\r\n     *  S1 = previous strike price\r\n     *  S2 = sale strike price\r\n     *\r\n     * @param _oldNotional Existing notional.\r\n     * @param _oldStrikePrice Existing strike price.\r\n     * @param _newStrikePrice New / Sale strike price.\r\n     * @return newNotional Result of the calculation.\r\n     */\r\n    function calculateNewNotional(\r\n        uint _oldNotional,\r\n        uint _oldStrikePrice,\r\n        uint _newStrikePrice\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint newNotional)\r\n    {\r\n        newNotional = (\r\n            _oldNotional.mul(\r\n                (_newStrikePrice.mul(FACTOR_UINT) / (_oldStrikePrice))\r\n            )\r\n        ) / (FACTOR_UINT);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the change in contract value based on the price change.\r\n     * @param _currentPrice Current market price\r\n     */\r\n    function changeInDai(\r\n        uint _strikePrice,\r\n        uint _currentPrice,\r\n        uint _notionalAmount\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint change)\r\n    {\r\n        uint changePercent = percentChange(_strikePrice, _currentPrice);\r\n        change = percentOf(_notionalAmount, changePercent);\r\n    }\r\n\r\n    /**\r\n     * @dev Return a percentage change comparing a value with a new value.\r\n     * @param _value The existing value to compare against\r\n     * @param _newValue The new value to compare the change against\r\n     * @return Percentage change (eg. _value = 100, _newValue = 90 then return 10)\r\n     */\r\n    function percentChange(uint _value, uint _newValue)\r\n        internal\r\n        pure\r\n        returns (uint percent)\r\n    {\r\n        if (_value == _newValue) return 0;\r\n        int changeAmount = int(_newValue) - int(_value);\r\n        int percentInt = (changeAmount * 100) / int(_value);\r\n        percent = uint((percentInt > 0) ? percentInt : -percentInt);\r\n    }\r\n\r\n    /**\r\n     * @dev Return a percentage of a given amount.\r\n     * @param _amount Amount to calculate the percentage of\r\n     * @param _percent Percent amount (1 - 100)\r\n     */\r\n    function percentOf(uint _amount, uint _percent)\r\n        internal\r\n        pure\r\n        returns (uint adjusted)\r\n    {\r\n        adjusted = (_amount * _percent) / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the collateral amount for one party given the current\r\n     *      market price and original strike price, notional amount and the\r\n     *      amount the party has deposited into the contract.\r\n     *\r\n     * @param _marketPrice Current market price\r\n     * @param _strikePrice CFD strike price\r\n     * @param _notionalAmount CFD notional amount\r\n     * @param _depositBalance Balances of deposits into the contract\r\n     * @param _isBuyer Buyer or Seller / Long or short party?\r\n     *\r\n     * @return collateral Amount of collateral for the party\r\n     */\r\n    function calculateCollateralAmount(\r\n        uint _strikePrice,\r\n        uint _marketPrice,\r\n        uint _notionalAmount,\r\n        uint _depositBalance,\r\n        bool _isBuyer\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint collateral)\r\n    {\r\n        // Formulas are:\r\n        //     Cl = depositBalanceLong  + N * (P - S) / S\r\n        //     Cs = depositBalanceShort - N * (P - S) / S\r\n        // however we need to use a multiplication factor to avoid fractions in\r\n        // solidity so these formulas are a little different to the above:\r\n        int N = int(_notionalAmount) * FACTOR_INT;\r\n        int So = int(_strikePrice);\r\n        int P = int(_marketPrice);\r\n        int D = int(_depositBalance);\r\n\r\n        int difference = (\r\n            N * (((P - So) * FACTOR_INT) / So) / FACTOR_INT\r\n        ) / FACTOR_INT;\r\n        int collateralInt = _isBuyer ? D + difference : D - difference;\r\n\r\n        assert(collateralInt >= 0);\r\n        collateral = uint(collateralInt);\r\n    }\r\n\r\n    function collateralInRange(\r\n        uint _notionalAmount,\r\n        uint _amount\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool inRange)\r\n    {\r\n        inRange = (_amount >= percentOf(_notionalAmount, MINIMUM_COLLATERAL_PERCENT)) &&\r\n            (_amount <= percentOf(_notionalAmount, MAXIMUM_COLLATERAL_PERCENT));\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate the cut off price for buyer or seller.\r\n     *\r\n     * This is the price that if passed would raise a liquidation event.\r\n     *\r\n     * Base Formulas are:\r\n     *     Buyer:  1.05 * S - depositBalanceLong  * S / N\r\n     *     Seller: 0.95 * S + depositBalanceShort * S / N\r\n     *\r\n     * However for Solidity we need to adjust parts by FACTOR_UINT to ensure\r\n     * no fractions.\r\n     *\r\n     * @param _notionalAmountDai Contract notional amount\r\n     * @param _depositBalance Balance of deposits for one party\r\n     *\r\n     * @return cut off price\r\n     */\r\n\r\n    function cutOffPrice(\r\n        uint _notionalAmountDai,\r\n        uint _depositBalance,\r\n        uint _strikePrice,\r\n        bool _calcForBuyerSide\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint price)\r\n    {\r\n        // 1st part: Buyer: [1.05 * S] or Seller: [0.95 * S]\r\n        uint strikePriceAdjuster = (_calcForBuyerSide) ?\r\n            BUYER_CUTOFF_ADJUSTMENT :\r\n            SELLER_CUTOFF_ADJUSTMENT;\r\n        uint strikeFivePercent = (_strikePrice * strikePriceAdjuster) / FACTOR_UINT;\r\n\r\n\r\n        // 2nd part: [depositBalance * S / N]\r\n        uint difference = (\r\n            _depositBalance * (_strikePrice * FACTOR_UINT) / _notionalAmountDai\r\n        ) / FACTOR_UINT;\r\n\r\n        // check for case where difference is greater (when buyer has deposits > notional)\r\n        // in this case we set the price to 0\r\n        if (_calcForBuyerSide && difference > strikeFivePercent)\r\n            return 0;\r\n\r\n        // finally: add or subtract the difference\r\n        price = (_calcForBuyerSide) ?\r\n            strikeFivePercent - difference :\r\n            strikeFivePercent + difference;\r\n    }\r\n\r\n}\r\n",
  "sourcePath": "D:\\Users\\Julien\\Desktop\\Work\\0xFutures\\protocol\\contracts\\cfd\\ContractForDifferenceLibrary.sol",
  "compiler": {
    "name": "solc",
    "version": "0.5.6+commit.b259423e.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.0.8",
  "updatedAt": "2019-05-16T06:11:23.306Z",
  "devdoc": {
    "methods": {},
    "title": "Contract for difference\r  * Contract for difference for a given market between a\r \"buyer\" (long position) and \"seller\" (short position).\r"
  },
  "userdoc": {
    "methods": {}
  }
}